
# Vulnerability To Key Compromise

Each role is associated with a threshold of keys, which provides compromise resilience in a way that when an attacker has compromised a single key (offline or an online key) and when tries to sign with that key, the client will reject the the partially signed file. In order to make the client accept the download, the role has to be signed with the total number of keys required for that role and so an attacker needs to compromise a threshold of keys pertaining to that role for a successful attack.

## Walkthrough 
Here, we attempt to sign the snapshot role file with less-than-a-threshold number of keys as defined for that role. And when the client requests for a file, it rejects the download because of `BadSignatureError('snapshot',)` error.

On server side, run the follwoing commands 
```Bash
# this assumes that password given to generate all private keys is 'password'
$ python
>>> from tuf.repository_tool import *
>>> repository = load_repository('repository')
>>> repository.root.version  #(output generated is 1)
>>> private_root_key = import_rsa_privatekey_from_file("keystore/root_key", password="password") 
>>> repository.root.load_signing_key(private_root_key)
>>> private_root_key2 = import_rsa_privatekey_from_file("keystore/root_key2", password="password")
>>> repository.root.load_signing_key(private_root_key2)
>>> repository.snapshot.threshold = 2
>>> private_snapshot_key = import_rsa_privatekey_from_file("keystore/snapshot_key", password="password")
>>> repository.snapshot.load_signing_key(private_snapshot_key)
>>> private_timestamp_key = import_rsa_privatekey_from_file("keystore/timestamp_key", password="password")
>>> repository.timestamp.load_signing_key(private_timestamp_key)
>>> repository.write('root')
>>> repository.write('snapshot')
>>> repository.write('timestamp')
>>> repository.root.version #(output generated is 2)
>>> repository.snapshot.version #(output generated is 3)
>>> repository.timestamp.version #(output generated is 5)

$ cp repository/metadata.staged/* repository/metadata

```
Then the client tries to refresh top level metadata which also includes partially signed snapshot metadata, which gets rejected as shown below
```Bash
$client.py --repo http://localhost:8001 file2.txt
```
The error we get says,
```Bash
Update failed from http://localhost:8001/metadata/snapshot.json.
Failed to update 'snapshot.json' from all mirrors: {'http://localhost:8001/metadata/snapshot.json': BadSignatureError('snapshot',)}
Metadata for 'snapshot' cannot be updated.
Error: No working mirror was found:
  'localhost:8001': BadSignatureError('snapshot',)
```

